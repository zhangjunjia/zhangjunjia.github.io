---
layout: post
title: 《深入理解计算机系统》读书笔记
date: '2015-11-21 15:18'
comments: true
categories: ['操作系统'] 
tags: ['操作系统']
---

本文为《深入理解计算机系统》的读书笔记。

<!--more-->

## 第1章 计算机系统漫游

### 编译系统的构成及工作过程

------

hello.c（源程序**文本**）↓

　　　　**预处理器(cpp)**↓

　　　　hello.i（被修改的源程序**文本**）↓

　　　　**编译器(ccl)**↓

　　　　hello.s（汇编程序**文本**）↓

　　　　**汇编器(as)**↓

　　　　hello.o（可重定位目标程序**二进制文件**）+printf.o（引用的库文件）↓

　　　　**链接器(ld)**↓

hello(可执行目标程序**二进制文件**)

------

<!--more-->

Q：多个C文件组成的程序是怎么被编译成一个程序的？	
A：一个.c文件+此c文件引用的所有.h文件汇编成.o文件，最后所有.o文件再链接成可执行二进制文件

Q：cpp在预处理过程将头文件的内容直接插入到程序文本中，对于多个C文件引用同一个H文件，那不是会导致重复插入？	
A：头文件使用如下方式定义可防止宏重复定义或重复引用头文件：

```c++
#ifndef    __SOMEFILE_H__
#define  __SOMEFILE_H__
...... // 一些声明语句
#endif
```

1) 预处理三种：宏定义+引用头文件+条件编译	

2) 在预处理阶段，多C文件引用头一个H文件，CPP预处理器还是会把H文件的内容插入到C文件的，但由于#ifndef的使用，程序在运行阶段并不会出现重复定义相同宏、相同变量或相同函数的情况。

### 系统的硬件组成

1. 总线：传送定长字节块(word)，即字；字的字节数（即字长）是一个基本的系统参数，如4字节（32位），8字节（64位）；
2. I/O设备：磁盘也是I/O设备，直接存储器存取（DMA）技术可以使数据不经处理器从磁盘直接到达主存；I/O设备通过一个控制器（置于I/O设备本身或主板上的芯片组）或适配器（插在主板插槽上的卡）与I/O总线相连；
3. 主存：动态随机存取存储器（DRAM），可看成一个极大的线性字节数组；
4. 处理器：负责解释存储在主存中的指令；核心是一个字长的存储设备（或寄存器），称为程序计数器（PC），任何时刻PC都指向主存中的一条机器语言指令（含有其地址），其次是寄存器文件和算术逻辑单元（ALU）；

Q：通常所说的32位机器和64位机器是由什么决定的？	
A：字长，即虚拟地址的字节数或总线传输的最小单元字的字节数。

Q：指令集结构和微体系结构的区别是什么？	
A：**TODO**

### 操作系统管理硬件

1. 操作系统：应用程序和硬件间的一层软件，1）防止硬件被失控的应用滥用；2）通过简单且一致的机制来控制复杂而又大相径庭的硬件设备；
2. 进程：并发指进一个进程的指令和其他进程的指令交错运行，实现这种交错运行叫做上下文切换，由内核代码负责，如保存PC、寄存器文件以及主存的内容；
3. 线程：多控制流并行（同时执行）；
4. 虚拟存储器：每个进程看到的是一致的存储器，即虚拟内存空间；地址从小到大依次是：	
	**程序文本(.text)**（程序二进制文件）↓	

	**文字常量区(.rodata)**（程序用到的常量字符串）↓	

	**已初始化数据(.data)**（已初始化的全局或静态全局变量）↓	

	**未初始化数据(.bss)**（未初始化的全局或静态全局变量）↓	

	**堆**（malloc伸，free缩，或结束时操作系统释放）↓	

	**共享库**（如标准库）↓	

	**栈**（函数参数值，局部变量值）↓	

	**内核虚拟存储器**
5. 文件：即字节序列，每个I/O设备都可以视为文件；

总结：文件是对I/O抽象，虚拟存储器是对主存抽象，进程是对运行程序抽象，虚拟机是对操作系统抽象。

Q：举例说明上文提到的虚拟存储器？	
A：如下
```c++
//main.cpp
int a = 0;          // 全局初始化区
char *p1;           // 全局未初始化区
                    // built-in type之外的类型都不会默认初始化
int main()
{
  int b;            // 栈区
  char s[] = "abc"; // 栈区
  char *p2;         // 栈区
  char *p3 = "123456";     // "123456/0" 在常量区，p3在栈区
  static int c =0;         // 全局（静态）初始化区
 
  p1 = (char *)malloc(10);
  p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区
 
  strcpy(p1, "123456");    // "123456/0" 放在常量区，编译器可能会将它
                              // 与p3所指向的"123456"优化成一个地方。
  return 0;
}
```

### 并发与并行

1. Inter Core i7有4个核心，每个核心可以执行2个线程（2个控制流，超线程），总共可以并行执行8个线程（多核+超线程）；
2. 指令级并行：处理器同时执行多条指令；
3. 单指令、多数据：允许一条指令产生多个可以并行执行的操作，称为单指令、多数据，如浮点数加法；

## 第2章 信息的表示和处理

### 信息存储

1. 虚拟地址空间是展示给进程的，为程序提供一个看上去统一的字节数组，实际实现要配合随机访问存储器（RAM）、磁盘、特殊硬件和操作系统；
2. 第1章提到的“字”的字节数即虚拟地址空间地址的字节数；
3. 大端法：human-readable，按从左到右的方式书写，左端是高位；小端法与大端法相反；对于文本不需要考虑大端还是小端法，文本具有更强的平台独立性；
4. 布尔运算与命题逻辑运算的对应：~对应NOT，&对应AND，|对应OR，^对应异或且`(a^b)^a=b`；
5. 掩码运算：`x&0xFF`，只保留x的低8位；
6. 逻辑运算||、&&和!与布尔运算的区别，1）运算不等价，逻辑运算的结果是0或1而布尔运算不然；2）结束条件不同，如果第一个运算就能确定逻辑运算表达式的值运算将终止；
7. 移位运算：左移右补k个0；逻辑右移左补k个0，算术右移左补k个最高有效位的值；**无符号右移必须是逻辑的，有符号右移默认是算术的根据编译器不同也可能是逻辑的**；Java用`>>`表示算术右移，`>>>`表示逻辑右移；在运算中比加减乘除优先级低；当移动位k大于被移动数位数w时，采用`k mod w`计算位移量；

### 整数表示

1. long、int在不同位级机器上位数不同，需慎用，尽量使用`intN_t`或`uintN_t`，N表示位数；另外在printf的格式化过程中也需要注意这个问题，如不同机器对`%ld`的解释是不同的，另外，`%d`表示有符号整数（取值范围为`-2^(w-1)`到`2^(w-1)-1`），`%u`表示无符号整数（取值范围为`0`到`2^w-1`）；
2. 补码表示负整数，最高位有效值表示负值；
3. w位有符号整数x→无符号，位级表示相同：
	- 负数→`x+2^w`，
	- 非负数→x
4. w位无符号整数u→有符号，位级表示相同：
	- u小于`2^(w-1)`→u，
	- u不小于`2^(w-1)`→`u-2^w`
5. T表示有符号整数x有w位，C语言中，`TMax=2^(w-1)-1`，`TMin=-TMax-1`
6. 零扩展添加0用于无符号数，符号扩展添加最高位有效值用于有符号数，高位转地位统一使用截断；
7. 慎用无符号数用于整数运算，有符号负数转为无符号数时将变成一个大数，可能导致不健壮程序代码溢出；

Q：为什么`TMin`要这样表示？	
A：**TODO**

### 整数运算

1. 无符号加法：
	- 超过`2^w`则减去`2^w`；
2. 有符号加法（与无符号加法位模式一致，但高位表示符号位）：
	- 超过`2^(w-1)`正溢出减去`2^w`（两个正数相加）
	- 小于`-2^(w-1)`负溢出加上`2^w`（两个负数相加）
	- 否则正常；
3. 补码非运算：
	- x等于`-2^(w-1)`时值不变高位
	- 否则等于-x；
4. 乘法：
	- `(x * y) mod 2^w`，对于有符号先按有符号计算后再转为有符号，即位级表示相同；
5. 乘以常数：
	- 化为位移和加减运算；
6. 除以2的幂：
	- 整数除法总是舍入到0，同号是向下取整的，异号是向上取整的；
	- “除以2的幂”可使用右移模拟整数除法
		- 无符号数逻辑右移等价于整数除法
		- 有符号非负数算术右移等价于整数除法
		- 有符号负数算术右移不等价于整数除法（如-5除以2的情况），加偏置的思想：y整除x时得k，否则得k+1

Q：证补码非等于其补加1：`-x=~x+1`	
A：根据定义分如下两种情况：

- 定义1：x等于-2^(w-1)时值不变，由定义立即得证
- 定义2：否则等于-x，等效于证明`~x+x+1=0`，`~x+x`的位全为1，立即得证

Q：为什么有符号负数算术右移：`(x+2^k-1) >> k`能正确舍入？	
A：**TODO**

### 浮点数

1. 二进制小数表示法的弊端，1）只能精确表示`x * 2^y`形式的数，2）对于大数需要非常多的位表示；
2. 浮点数定义：`(-1)^s * M * 2^E`
	- s为符号sign，由第一位表示；
	- M是尾数significand，由末尾的n位小数表示的二进制小数frac（简称f）表示；
	- E是阶码exponet，由中间k位的小数exp（简称e）表示，负责对M加权；
	- 它在位上的排列是（大端法）：s | exp | frac；
3. 浮点数分类：
	- 非规格化：frac的位全为0，此时`M=f`，`E=1-Bias`，`Bias=2^(k-1) - 1`；
	- 规格化：frac的位不全为1，此时`M=1+f`，`E=e-Bias`，`Bias=2^(k-1) - 1`；
	- 特殊值：frac的位全为1，当exp全为0表示无穷大，否则表示NaN；
4. 浮点数偶数舍入
	- 将数字向上或向下舍入，使结果最低有效数字位是偶数，如浮点数2.5和1.5的最低有效数字位是个位数的情况下都舍入到2
	- 适用于二进制数，二进制0是偶数，1是奇数

Q：浮点数比二进制小数编码优异的地方在哪	
A：**TODO**

Q：为什么要这样子编码浮点数	
A：**TODO**

Q：试举例将正整数12345做浮点数二进制表示		
A：使用4个字节32位的单精度浮点数来编码，其中阶码k=8，尾数n=23，十进制12345二进制表示为：0000,0011,0000,0011,1001
1. 由定义可知最大非规格化数`f*2^(1-Bias)`肯定是小于1的，因此12345肯定是使用规格化数字表示；
2. 0000,0011,0000,0011,1001 = 二进制的1.**1,0000,0011,1001** * 2^13，由定义得**1,0000,0011,1001**等于f，f求得；而13=E=e-Bias=e-128得e的十进制表示为141即二进制1000,1101
3. 则其浮点数二进制表示为0, 1000,1101, 000,0000,0001,0000,0011,1001
